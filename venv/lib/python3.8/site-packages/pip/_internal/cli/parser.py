"""Base option parser setup"""

<<<<<<< HEAD
# The following comment should be removed at some point in the future.
# mypy: disallow-untyped-defs=False

from __future__ import absolute_import

import logging
import optparse
import sys
import textwrap
from distutils.util import strtobool

from pip._vendor.six import string_types

from pip._internal.cli.status_codes import UNKNOWN_ERROR
from pip._internal.configuration import Configuration, ConfigurationError
from pip._internal.utils.compat import get_terminal_size
=======
import logging
import optparse
import shutil
import sys
import textwrap
from contextlib import suppress
from typing import Any, Dict, Generator, List, Tuple

from pip._internal.cli.status_codes import UNKNOWN_ERROR
from pip._internal.configuration import Configuration, ConfigurationError
from pip._internal.utils.misc import redact_auth_from_url, strtobool
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9

logger = logging.getLogger(__name__)


class PrettyHelpFormatter(optparse.IndentedHelpFormatter):
    """A prettier/less verbose help formatter for optparse."""

<<<<<<< HEAD
    def __init__(self, *args, **kwargs):
        # help position must be aligned with __init__.parseopts.description
        kwargs['max_help_position'] = 30
        kwargs['indent_increment'] = 1
        kwargs['width'] = get_terminal_size()[0] - 2
        optparse.IndentedHelpFormatter.__init__(self, *args, **kwargs)

    def format_option_strings(self, option):
        return self._format_option_strings(option)

    def _format_option_strings(self, option, mvarfmt=' <{}>', optsep=', '):
=======
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        # help position must be aligned with __init__.parseopts.description
        kwargs["max_help_position"] = 30
        kwargs["indent_increment"] = 1
        kwargs["width"] = shutil.get_terminal_size()[0] - 2
        super().__init__(*args, **kwargs)

    def format_option_strings(self, option: optparse.Option) -> str:
        return self._format_option_strings(option)

    def _format_option_strings(
        self, option: optparse.Option, mvarfmt: str = " <{}>", optsep: str = ", "
    ) -> str:
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        """
        Return a comma-separated list of option strings and metavars.

        :param option:  tuple of (short opt, long opt), e.g: ('-f', '--format')
        :param mvarfmt: metavar format string
        :param optsep:  separator
        """
        opts = []

        if option._short_opts:
            opts.append(option._short_opts[0])
        if option._long_opts:
            opts.append(option._long_opts[0])
        if len(opts) > 1:
            opts.insert(1, optsep)

        if option.takes_value():
<<<<<<< HEAD
            metavar = option.metavar or option.dest.lower()
            opts.append(mvarfmt.format(metavar.lower()))

        return ''.join(opts)

    def format_heading(self, heading):
        if heading == 'Options':
            return ''
        return heading + ':\n'

    def format_usage(self, usage):
=======
            assert option.dest is not None
            metavar = option.metavar or option.dest.lower()
            opts.append(mvarfmt.format(metavar.lower()))

        return "".join(opts)

    def format_heading(self, heading: str) -> str:
        if heading == "Options":
            return ""
        return heading + ":\n"

    def format_usage(self, usage: str) -> str:
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        """
        Ensure there is only one newline between usage and the first heading
        if there is no description.
        """
<<<<<<< HEAD
        msg = '\nUsage: {}\n'.format(
            self.indent_lines(textwrap.dedent(usage), "  "))
        return msg

    def format_description(self, description):
        # leave full control over description to us
        if description:
            if hasattr(self.parser, 'main'):
                label = 'Commands'
            else:
                label = 'Description'
            # some doc strings have initial newlines, some don't
            description = description.lstrip('\n')
=======
        msg = "\nUsage: {}\n".format(self.indent_lines(textwrap.dedent(usage), "  "))
        return msg

    def format_description(self, description: str) -> str:
        # leave full control over description to us
        if description:
            if hasattr(self.parser, "main"):
                label = "Commands"
            else:
                label = "Description"
            # some doc strings have initial newlines, some don't
            description = description.lstrip("\n")
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
            # some doc strings have final newlines and spaces, some don't
            description = description.rstrip()
            # dedent, then reindent
            description = self.indent_lines(textwrap.dedent(description), "  ")
<<<<<<< HEAD
            description = '{}:\n{}\n'.format(label, description)
            return description
        else:
            return ''

    def format_epilog(self, epilog):
=======
            description = f"{label}:\n{description}\n"
            return description
        else:
            return ""

    def format_epilog(self, epilog: str) -> str:
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        # leave full control over epilog to us
        if epilog:
            return epilog
        else:
<<<<<<< HEAD
            return ''

    def indent_lines(self, text, indent):
        new_lines = [indent + line for line in text.split('\n')]
=======
            return ""

    def indent_lines(self, text: str, indent: str) -> str:
        new_lines = [indent + line for line in text.split("\n")]
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        return "\n".join(new_lines)


class UpdatingDefaultsHelpFormatter(PrettyHelpFormatter):
    """Custom help formatter for use in ConfigOptionParser.

    This is updates the defaults before expanding them, allowing
    them to show up correctly in the help listing.
<<<<<<< HEAD
    """

    def expand_default(self, option):
        if self.parser is not None:
            self.parser._update_defaults(self.parser.defaults)
        return optparse.IndentedHelpFormatter.expand_default(self, option)


class CustomOptionParser(optparse.OptionParser):

    def insert_option_group(self, idx, *args, **kwargs):
=======

    Also redact auth from url type options
    """

    def expand_default(self, option: optparse.Option) -> str:
        default_values = None
        if self.parser is not None:
            assert isinstance(self.parser, ConfigOptionParser)
            self.parser._update_defaults(self.parser.defaults)
            assert option.dest is not None
            default_values = self.parser.defaults.get(option.dest)
        help_text = super().expand_default(option)

        if default_values and option.metavar == "URL":
            if isinstance(default_values, str):
                default_values = [default_values]

            # If its not a list, we should abort and just return the help text
            if not isinstance(default_values, list):
                default_values = []

            for val in default_values:
                help_text = help_text.replace(val, redact_auth_from_url(val))

        return help_text


class CustomOptionParser(optparse.OptionParser):
    def insert_option_group(
        self, idx: int, *args: Any, **kwargs: Any
    ) -> optparse.OptionGroup:
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        """Insert an OptionGroup at a given position."""
        group = self.add_option_group(*args, **kwargs)

        self.option_groups.pop()
        self.option_groups.insert(idx, group)

        return group

    @property
<<<<<<< HEAD
    def option_list_all(self):
=======
    def option_list_all(self) -> List[optparse.Option]:
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        """Get a list of all options, including those in option groups."""
        res = self.option_list[:]
        for i in self.option_groups:
            res.extend(i.option_list)

        return res


class ConfigOptionParser(CustomOptionParser):
    """Custom option parser which updates its defaults by checking the
    configuration files and environmental variables"""

<<<<<<< HEAD
    def __init__(self, *args, **kwargs):
        self.name = kwargs.pop('name')

        isolated = kwargs.pop("isolated", False)
        self.config = Configuration(isolated)

        assert self.name
        optparse.OptionParser.__init__(self, *args, **kwargs)

    def check_default(self, option, key, val):
        try:
            return option.check_value(key, val)
        except optparse.OptionValueError as exc:
            print("An error occurred during configuration: {}".format(exc))
            sys.exit(3)

    def _get_ordered_configuration_items(self):
=======
    def __init__(
        self,
        *args: Any,
        name: str,
        isolated: bool = False,
        **kwargs: Any,
    ) -> None:
        self.name = name
        self.config = Configuration(isolated)

        assert self.name
        super().__init__(*args, **kwargs)

    def check_default(self, option: optparse.Option, key: str, val: Any) -> Any:
        try:
            return option.check_value(key, val)
        except optparse.OptionValueError as exc:
            print(f"An error occurred during configuration: {exc}")
            sys.exit(3)

    def _get_ordered_configuration_items(
        self,
    ) -> Generator[Tuple[str, Any], None, None]:
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        # Configuration gives keys in an unordered manner. Order them.
        override_order = ["global", self.name, ":env:"]

        # Pool the options into different groups
<<<<<<< HEAD
        section_items = {name: [] for name in override_order}
=======
        section_items: Dict[str, List[Tuple[str, Any]]] = {
            name: [] for name in override_order
        }
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        for section_key, val in self.config.items():
            # ignore empty values
            if not val:
                logger.debug(
                    "Ignoring configuration key '%s' as it's value is empty.",
<<<<<<< HEAD
                    section_key
=======
                    section_key,
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
                )
                continue

            section, key = section_key.split(".", 1)
            if section in override_order:
                section_items[section].append((key, val))

        # Yield each group in their override order
        for section in override_order:
            for key, val in section_items[section]:
                yield key, val

<<<<<<< HEAD
    def _update_defaults(self, defaults):
=======
    def _update_defaults(self, defaults: Dict[str, Any]) -> Dict[str, Any]:
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        """Updates the given defaults with values from the config files and
        the environ. Does a little special handling for certain types of
        options (lists)."""

        # Accumulate complex default state.
        self.values = optparse.Values(self.defaults)
        late_eval = set()
        # Then set the options with those values
        for key, val in self._get_ordered_configuration_items():
            # '--' because configuration supports only long names
<<<<<<< HEAD
            option = self.get_option('--' + key)
=======
            option = self.get_option("--" + key)
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9

            # Ignore options not present in this parser. E.g. non-globals put
            # in [global] by users that want them to apply to all applicable
            # commands.
            if option is None:
                continue

<<<<<<< HEAD
            if option.action in ('store_true', 'store_false', 'count'):
                try:
                    val = strtobool(val)
                except ValueError:
                    error_msg = invalid_config_error_message(
                        option.action, key, val
                    )
                    self.error(error_msg)

            elif option.action == 'append':
                val = val.split()
                val = [self.check_default(option, key, v) for v in val]
            elif option.action == 'callback':
=======
            assert option.dest is not None

            if option.action in ("store_true", "store_false"):
                try:
                    val = strtobool(val)
                except ValueError:
                    self.error(
                        "{} is not a valid value for {} option, "  # noqa
                        "please specify a boolean value like yes/no, "
                        "true/false or 1/0 instead.".format(val, key)
                    )
            elif option.action == "count":
                with suppress(ValueError):
                    val = strtobool(val)
                with suppress(ValueError):
                    val = int(val)
                if not isinstance(val, int) or val < 0:
                    self.error(
                        "{} is not a valid value for {} option, "  # noqa
                        "please instead specify either a non-negative integer "
                        "or a boolean value like yes/no or false/true "
                        "which is equivalent to 1/0.".format(val, key)
                    )
            elif option.action == "append":
                val = val.split()
                val = [self.check_default(option, key, v) for v in val]
            elif option.action == "callback":
                assert option.callback is not None
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
                late_eval.add(option.dest)
                opt_str = option.get_opt_string()
                val = option.convert_value(opt_str, val)
                # From take_action
                args = option.callback_args or ()
                kwargs = option.callback_kwargs or {}
                option.callback(option, opt_str, val, self, *args, **kwargs)
            else:
                val = self.check_default(option, key, val)

            defaults[option.dest] = val

        for key in late_eval:
            defaults[key] = getattr(self.values, key)
        self.values = None
        return defaults

<<<<<<< HEAD
    def get_default_values(self):
=======
    def get_default_values(self) -> optparse.Values:
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
        """Overriding to make updating the defaults after instantiation of
        the option parser possible, _update_defaults() does the dirty work."""
        if not self.process_default_values:
            # Old, pre-Optik 1.5 behaviour.
            return optparse.Values(self.defaults)

        # Load the configuration, or error out in case of an error
        try:
            self.config.load()
        except ConfigurationError as err:
            self.exit(UNKNOWN_ERROR, str(err))

        defaults = self._update_defaults(self.defaults.copy())  # ours
        for option in self._get_all_options():
<<<<<<< HEAD
            default = defaults.get(option.dest)
            if isinstance(default, string_types):
=======
            assert option.dest is not None
            default = defaults.get(option.dest)
            if isinstance(default, str):
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
                opt_str = option.get_opt_string()
                defaults[option.dest] = option.check_value(opt_str, default)
        return optparse.Values(defaults)

<<<<<<< HEAD
    def error(self, msg):
        self.print_usage(sys.stderr)
        self.exit(UNKNOWN_ERROR, "{}\n".format(msg))


def invalid_config_error_message(action, key, val):
    """Returns a better error message when invalid configuration option
    is provided."""
    if action in ('store_true', 'store_false'):
        return ("{0} is not a valid value for {1} option, "
                "please specify a boolean value like yes/no, "
                "true/false or 1/0 instead.").format(val, key)

    return ("{0} is not a valid value for {1} option, "
            "please specify a numerical value like 1/0 "
            "instead.").format(val, key)
=======
    def error(self, msg: str) -> None:
        self.print_usage(sys.stderr)
        self.exit(UNKNOWN_ERROR, f"{msg}\n")
>>>>>>> ac06c7b6fac3fafcccabadf3fa88f16377c619c9
